#include <stdio.h>
#include <malloc.h>
#include <string>
#include <math.h>
constexpr auto MAXSIZE = 40;;
/* 顺序栈结构 */
typedef struct
{
	char Sign[MAXSIZE];
	int top; /* 用于栈顶指针 */
}SignStack;

typedef struct
{
	double Number[MAXSIZE];
	int top;/* 用于栈顶指针*/
}NumberStack;

int Priority(char n);//返回元素优先级
bool GetTopSign(SignStack S, char* e);
bool GetTop(NumberStack S, double* e);
double GetResult(SignStack mSign, NumberStack mNum,char* IN);

bool Pop(NumberStack* S, double* e);
bool PopSign(SignStack* S, char* e);
bool Push(NumberStack* S, double e);
bool PushSign(SignStack* S, char e);
bool NeedPush(SignStack* S,char e,bool* shouldhaveleft);
bool IsNumber(char c);		  /*判断字符c是否为数字*/
bool NeedCalcular(char c);
char SdInput(char** mIn);/*判断sin cos lg ln + - * / ( )等操作符的输入*/
double Calcular(double n, double m, char sign, bool* OpTopSign);

void PrintStack(NumberStack* S);
void PrintSignStack(SignStack* S);

int main() {
	char IN[100];
	char* mIn = IN;
	gets_s(IN);
	SignStack mSign;
	NumberStack mNum;
	mSign.top = -1;
	mNum.top = -1;
	
	double sum;
	sum = GetResult(mSign, mNum,mIn);
	printf("The result of the formula is %.2f\n", sum);
	return 0;
}

double GetResult(SignStack mSign, NumberStack mNun,char* mIn) {
	char Scan,e;
	double sum = 0, m,n;
	bool haveNum = false;//当前字符输入之前是否有数字
	bool PopLeft = false;//是否需要将字符栈中的左括号弹出
	bool OpTopSign = false;//是否只对栈顶元素进行操作，如sin,cos函数
	int re = 0;

	do {

		Scan = *mIn;
		if (IsNumber(Scan) == true)//当前字符为数字
		{
			re = 10 * re + ((int)Scan - '0');
			haveNum = true;
		}
		else {//当前字符为操作符，需存入字符栈
			//如果上一个数据为数字，则先存入数字栈
			if (haveNum){
				
				Push(&mNun, re);
				re = 0;
				haveNum = false;
			}
			//入栈需判断与栈顶符号的优先级,高于栈顶元素时入栈
			printf("The top is %c\n", *mIn);
			Scan = SdInput(&mIn);
			printf("The end is %c\n", *mIn);
			if (mSign.top != -1) {//字符栈非空时需要判断是否入栈
				if (NeedPush(&mSign, Scan, &PopLeft)) {
					PushSign(&mSign, Scan);
					
				}
				else {
					/*需要进行出栈，运算，最后运算符的进栈操作‘+ - * / （ ） =’
					  栈顶元素需要出栈，接下来判断所有需要出栈的值
					  并且在出栈操作时进行运算*/
					/*需要对左右括号进行单独判断*/
					do {
						PopLeft = false;
						PrintStack(&mNun);
						PrintSignStack(&mSign);

						PopSign(&mSign, &e);//e为需要对m和n进行的操作
						if (e == ')') {
							PopLeft = true;
						}
						
						if (NeedCalcular(e)) {
							OpTopSign = false;
							Pop(&mNun, &m);
							Pop(&mNun, &n);
							double mRe = Calcular(m, n, e, &OpTopSign);///暂时定为int之后进行更改
							if (OpTopSign) {//栈顶元素为m,若返回的OpTopSign为true则需要将n压栈
								Push(&mNun, n);
							}
							Push(&mNun, mRe);
							e = 0;
						}
					} while (!NeedPush(&mSign, Scan,&PopLeft));
					PushSign(&mSign, Scan);
				}
			}else {
				PushSign(&mSign, Scan);
			}
		}
		
		mIn++;
	} while (*mIn != '\0');
	GetTop(mNun,&sum);
	
	return sum;
}

char SdInput(char** mIn) {
	switch (**mIn)
	{
	case '+':
		return '+';
	case '-':
		return '-';
	case '*':
		return '*';
	case '/':
		return '/';
	case '(':
		return '(';
	case')':
		return ')';
	case's':
		*mIn += 2;
		return 's';//用s来代表sin函数
	case'c':
		*mIn += 3;
		return 'c';//用c来代表cos函数
	case'l':
		*mIn++;
		if (**mIn == 'n') {
			return 'n';//用n来代表ln函数
		}else {
			*mIn++;
			return 'g';//用g来代表log函数
		}
	case '^':
		return '^';//乘方
	case '=':
		return '=';
	default:
		break;
	}
}

void PrintSignStack(SignStack* S) {
	int prim = S->top;
	while (prim!=-1)
	{		
		prim--;
	}
}

void PrintStack(NumberStack* S)
{
	int prim = S->top;
	while (prim!=-1)
	{		
		prim--;
	}
}
bool NeedCalcular(char sign)
{
	switch (sign)
	{
	case '+':
		return true;
	case '-':
		return true;
	case '*':
		return true;
	case '/':
		return true;
	case '^':
		return true;
	case 'c':
		return true;
	case 's':
		return true;
	case 'g':
		return true;
	case 'n':
		return true;
	default:
		break;
	}
	return false;
}

double Calcular(double m, double n, char sign, bool* OpTopSign) {//m为栈顶元素
	switch (sign)
	{
	case '+':
		return n + m;
	case '-':
		return n - m;
	case '*':
		return n * m;
	case '/':
		return n /m;
	case '^':
		*OpTopSign=true;
		return pow(n,m);
	case 'c':
		*OpTopSign = true;
		printf("cos(%lf)\n",m);
		return cos(m);
	case 's':
		*OpTopSign = true;
		return sin(m);
	case 'g':
		*OpTopSign = true;
		return log10(m);
	case 'n':
		*OpTopSign = true;
		return log(m);
	default:
		break;
	}
}

bool NeedPush(SignStack* S, char e,bool* popLeft)
{
	
	if ((Priority(S->Sign[S->top])< Priority(e))||S->top==-1||((S->Sign[S->top] == '(') &&(*popLeft==false ))) {
		return true;//true时执行进栈操作
	}
	else if (((S->Sign[S->top] == '(') && (*popLeft == true))) {//需要将左括号出栈
		*popLeft = false;
		return false;
	}
	else {
		return false;
	}
}

/* 插入元素e为新的栈顶元素 */
bool Push(NumberStack* S, double e)
{
	if (S->top == MAXSIZE - 1) /* 栈满 */
	{
		return false;
	}
	S->top++;				/* 栈顶指针增加一 */
	S->Number[S->top] = e;  /* 将新插入元素赋值给栈顶空间 */
	return true;
}

bool PushSign(SignStack* S, char e)
{
	if (S->top == MAXSIZE - 1) /* 栈满 */
	{
		return false;
	}
	S->top++;				/* 栈顶指针增加一 */
	S->Sign[S->top] = e;  /* 将新插入元素赋值给栈顶空间 */
	return true;
}

/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回true；否则返回false */
bool Pop(NumberStack* S, double* e)
{
	if (S->top == -1)
		return false;
	*e = S->Number[S->top];	/* 将要删除的栈顶元素赋值给e */
	S->top--;				/* 栈顶指针减一 */
	return true;
}

bool PopSign(SignStack* S, char* e)
{
	if (S->top == -1)
		return false;
	*e = S->Sign[S->top];	/* 将要删除的栈顶元素赋值给e */
	S->top--;				/* 栈顶指针减一 */
	return true;
}

/* 若栈不空，则用e返回S的栈顶元素，并返回1；否则返回0 */
bool GetTop(NumberStack S, double* e) {
	if (S.top == -1)
		return false;
	else
		*e = S.Number[S.top];
	return true;
}

bool GetTopSign(SignStack S, char* e) {
	if (S.top == -1)
		return false;
	else
		*e = S.Sign[S.top];
	return true;
}

bool IsNumber(char c) {
	if (c >= '0' && c <= '9')
		return true;
	else
		return false;
}

int Priority(char n) {
	if (n == '=')
		return 0;
	
	if (n == 's' || n == 'c' || n == 't' || n == 'g' || n == 'n')
		return 1;

	if (n == '+' || n == '-')
		return 2;
	if (n == '*' || n == '/')
		return 3;
	if (n == '^')
		return 4;
	if (n == ')')
		return 0;
}